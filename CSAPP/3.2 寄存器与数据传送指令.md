## 3.2 寄存器与数据传送指令
### 寄存器介绍
![[storage bag/Screenshot 2023-11-16 at 19.08.04.png]]
最早8086处理器中，包含8个16位通用寄存器。
处理器扩展到32位时，寄存器的位数也随之扩展到了32位。
直到今天的64位处理器中，寄存器扩展成了64位，还增加了8个新的寄存器。
![[storage bag/Screenshot 2023-11-16 at 19.10.27.png]]
在一般的程序中，不同的寄存器扮演者不同的角色，相应的编程规范规定了如何使用这些寄存器，例如寄存器rax用来保存函数的返回值；寄存器rsp用来保存程序栈的结束位置。除此之外，还有6个寄存器可以用来传递函数参数。 ^1e2683

![[storage bag/Screenshot 2023-11-16 at 19.10.48.png]] 

### 指令
大多数指令包含两部分：操作码和操作数，不同指令的操作数大致可以分为三类：立即数、寄存器以及内存引用。
![[storage bag/Screenshot 2023-11-16 at 19.16.47.png]]
在AT&T格式的汇编中，立即数时以`$`符号开头的，后面跟一个整数（该整数需要满足标准C语言的定义）；
64位处理器上，不仅64位的寄存器可以作为操作数，32、16甚至8位的寄存器都可以作为操作数；
图中带有小括号的寄存器，所表示的是**内存引用**。

#### 内存引用

![[storage bag/Screenshot 2023-11-16 at 19.18.40.png]]

编译器会根据数组的类型来确定比例因子的数值，如定义`char`类型的数组，比例因子就是1；`int`类型，比例因子就是4...... ^cb8c4a

其它形成的内存引用都是这种普通形式的变种。

![[storage bag/Screenshot 2023-11-16 at 19.23.26.png]]
> 目的操作数不能是一个立即数。

x86-64处理器还有限制“原操作数和目的操作数不能都是内存的地址”
![[storage bag/Screenshot 2023-11-16 at 19.33.21.png]]
>  用两条mov指令完成：第一条指令将内存源未知的数值加载到寄存器，第二条指令将该寄存器的值写入内存的目的位置。

要注意的是，`mov`指令的后缀与寄存器的大小一定得匹配：
![[storage bag/Screenshot 2023-11-16 at 19.37.48.png]]

几个特殊情况：

movq指令的原操作数是立即数时，该立即数只能是32位的**补码**表示，然后对该数值进行符号位扩展之后，将得到的64位数传送到目的位置。
当处理立即数时64位的时候，引入一个新的指令-movabsq，目的操作数只能是寄存器。
![[storage bag/Screenshot 2023-11-16 at 19.39.01.png]]

![[storage bag/Screenshot 2023-11-16 at 19.48.02.png]]

```asm
movb $-1 %al
```

![[storage bag/Screenshot 2023-11-16 at 19.58.18.png]]

当mov指令将立即数-1复制到寄存器eax时，此时寄存器rax不仅仅是低32位发生了变化，而且高32位也发生了变化。当movl的目的操作数时寄存器时，它会把该寄存器的高4字节设置为0，这是x86-64处理器的一个规定。
![[storage bag/Screenshot 2023-11-16 at 19.58.43.png]]

最后，符号位扩展还有一条没有操作数的特殊指令`cltq`，该指令的原操作数总是eax，目的操作数总是寄存器rax。

![[storage bag/Screenshot 2023-11-16 at 19.46.51.png]]
> 两条指令等效，前者编码更紧凑