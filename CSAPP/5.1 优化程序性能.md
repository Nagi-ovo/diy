![](storage%20bag/Screenshot%202024-02-29%20at%2008.11.56.png)

![](storage%20bag/Screenshot%202024-02-29%20at%2008.32.27.png)
> add1:6次内存引用，add2:3次内存引用。编译器优化代码时，会假设xp和yp有可能指向相同位置，因此add2并不是add1的优化版。

两个指针可能指向同一个内存位置被称为**内存别名使用**。

另一个例子：
![](storage%20bag/Screenshot%202024-02-29%20at%2008.38.58.png)

编译器会假设所有的情况都有可能发生，这就限制了可能的优化策略。

另一个妨碍优化的因素是函数调用：

![](storage%20bag/Screenshot%202024-02-29%20at%2008.43.41.png)

![](storage%20bag/Screenshot%202024-02-29%20at%2008.47.18.png)

![](storage%20bag/Screenshot%202024-02-29%20at%2008.49.04.png)
> 同样是循环，psum2一次迭代可以计算出两个元素的值

这种技术称为**循环展开**，

为了评估程序的性能，引入一个新的度量标准：**CPE**，表示每个元素执行所需要的周期数，而不是每次循环所需要的周期数。

![](storage%20bag/Screenshot%202024-02-29%20at%2008.55.56.png)
> psum1 CPE: 9.0
> psum2 CPE: 6.0

我们在优化程序的性能时，应该集中精力减小计算的CPE。

# 5.2 继续优化

![](storage%20bag/Screenshot%202024-02-29%20at%2009.12.46.png)

可以在循环开始之前就调用vec_length，结果赋值给局部变量。这种优化方式被称为**代码移动**。

为什么编译器无法自动完成代码移动来提升性能呢？原因是编译器无法判断进行代码移动后是否会产生副作用，所以这类优化需要程序员来完成。

一个看似不重要的片段却能导致严重的性能问题。

有时，代码中的一些其它限制因素对性能的限制能超过函数调用：

![](storage%20bag/Screenshot%202024-02-29%20at%2009.25.16.png)
> 其中涉及到两次读内存和一次写内存的操作

![](storage%20bag/Screenshot%202024-02-29%20at%2009.29.25.png)

这样的读写操作很浪费时间，

引入一个临时变量acc(记录累积的结果，循环结束后再把结果写回目的地址)来消除不必要的内存引用:

![](storage%20bag/Screenshot%202024-02-29%20at%2009.29.57.png)
> 修改后，每次迭代只需要一次读内存操作

![](storage%20bag/Screenshot%202024-02-29%20at%2009.31.16.png)

那么究竟是什么因素在制约代码的性能呢？

