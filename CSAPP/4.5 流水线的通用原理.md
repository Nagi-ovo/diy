## 未流水化的硬件设计

1皮秒=$10^{-12}$秒

![](storage%20bag/Screenshot%202024-02-27%20at%2016.28.45.png)
> 延迟，也就是一条指令从开始执行到结束所需要的时间。

![](storage%20bag/Screenshot%202024-02-27%20at%2016.31.15.png)

在这个非流水化的实现中，开始下一条指令前，必须完成上一条指令的执行，因此指令的执行不存在相互重叠的情况。

为了评估上述系统的执行效率，我们引入吞吐量的概念，吞吐量的单位定义为每秒千兆条指令（GIPS），也就是每秒十亿条指令：

![](storage%20bag/Screenshot%202024-02-27%20at%2016.34.05.png)

所以，该系统的最大吞吐量:
$$Throughput\approx 3.12GIPS$$

## 流水线

![](storage%20bag/Screenshot%202024-02-27%20at%2016.38.06.png)


![](storage%20bag/Screenshot%202024-02-27%20at%2016.39.15.png)

只要指令1从A阶段进入B阶段之后，就可以让指令2进入A阶段，以此类推，在稳定的情况下，三个阶段都是处于运行状态。之后，系统每隔120ps，就有一条指令离开系统，一条新的指令进入。因此，该流水化系统的吞吐量为$1s/120ps\approx8.33GIPS$，与非流水化的设计相比提高了约2.67倍。

## 流水线操作

指令在流水线各个阶段的转移是由时钟信号来控制的，每隔120ps，信号从0上升至1，流水线开始下一个阶段的计算。
当时刻0时，此时流水线所有部件处于空闲状态。首先看一下时钟上升之前，时刻239ps处的流水线状态，此时，指令1经过阶段B地计算结果已经达到第二个寄存器的输入，指令2经过阶段A的计算结果已经达到第一个寄存器的输入。

![](storage%20bag/Screenshot%202024-02-27%20at%2016.49.48.png) 
> 指令1用青色表示，指令2用金色表示

此时，第一个寄存器还保存着指令1在阶段A的计算结果。当时钟上升时（241ps），第一个寄存器的状态就由指令1的结果变成了指令2的结果，第二个寄存器的状态用来保存指令2在阶段B的执行结果：

![](storage%20bag/Screenshot%202024-02-27%20at%2016.51.45.png)
> 同时，阶段A的输入被设置为发起指令3的计算。

时刻359ps的状态，指令1经过阶段C的计算结果已经达到第三个寄存器的输入，指令2经过阶段B达到第二个寄存器的输入，指令1经过阶段A达到第一个寄存器的输入：

![](storage%20bag/Screenshot%202024-02-27%20at%2016.52.31.png)

接下来当时时钟上升时，三个寄存器的值都会发生改变：
 
![](storage%20bag/Screenshot%202024-02-27%20at%2016.53.54.png)

可以把寄存器看作各个阶段之间的屏障，因此指令之间不会相互干扰。

上述是理想状态的流水化系统。实际上会有一些其他因素，影响流水线的效率。对于硬件设计者，将一个整体的设计划分成多个延迟都相等的子阶段是一个严峻的挑战，现实情况中，各个阶段的延迟可能都是不等的，虽然三个阶段的延迟加起来依旧是300ps，但是时钟的速率受最慢阶段的限制，时钟周期需要设置成170ps：

![](storage%20bag/Screenshot%202024-02-27%20at%2016.57.54.png)
> 此时，阶段A会有100ps的空闲，阶段C会有50ps的空闲

相对于理想情况下，系统的吞吐量从8.33GIPS下降到5.88GIPS。

此外，还有另一个局限性。当我们把计算过程分成更多的阶段时，系统的吞吐量也提升了。与三级流水相比，六级流水的吞吐量提升了1.71倍，虽然增加流水线的阶段数可以提升系统吞吐量，但是**过深的流水线同样也会导致系统性能的下降**。 

### Data Dependency

在之前的例子中，我们假设指令之间都是相互独立的，但实际程序中，指令之间是有依赖关系的，这被称为“数据依赖”。

^279f15

![|350](storage%20bag/Screenshot%202024-02-27%20at%2017.41.09.png)

### Control Dependency

还有一种依赖是由于指令控制流造成的控制依赖，如下面汇编代码中，跳转指令会产生一个控制依赖，因为条件测试结果会决定要顺序执行irmovq指令，还是执行halt指令。

在顺序结构的设计中，这些相关是通过反馈来解决的。不过在流水线系统中引入反馈路径是非常危险的，如指令4的输入需要依赖指令1的执行结果，为了通过流水线技术加速系统而改变系统的行为，这种行为是不可接受的。

![](storage%20bag/Screenshot%202024-02-27%20at%2017.46.11.png)

我们必须以某种方式来处理指令间的数据和控制依赖。