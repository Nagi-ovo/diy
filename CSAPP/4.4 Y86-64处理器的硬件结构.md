## Fetch Stage
![](storage%20bag/Screenshot%202024-02-27%20at%2014.35.07.png)
> 统一取10 Bytes是因为在取指操作之前，无法判断当前指令的长度，而Y86-64指令系统中最长的指令占10个字节。这样可以保证一次取指操作至少可以获取一条完整的Y86-64指令。

![](storage%20bag/Screenshot%202024-02-27%20at%2014.37.05.png)  
## Decode Stage

![](storage%20bag/Screenshot%202024-02-27%20at%2014.38.47.png)
> 图示的几条指令在译码阶段都需要读寄存器rsp的内容，所以译码阶段不仅需要rA和rB信号，还需要icode信号 

## Execute Stage

执行阶段的核心部件是算术逻辑单元ALU，ALU根据指令功能(ifun)来判断对输入的操作数进行何种运算，每次运行时，ALU都会产生三个与条件码相关的信号——零、符号、溢出。不过我们只希望ALU在执行算术逻辑指令时才会设置条件码，当ALU计算内存引用地址以及对栈进行操作时，并不会设置条件码。因此，图中Set_CC会根据指令代码icode来控制是否要更新条件码寄存器。

标号为cond的硬件单元回根据指令功能和条件码寄存器产生一个cnd信号，对于跳转指令，如果cnd=1，执行跳转；cnd=0，则不执行跳转。

![](storage%20bag/Screenshot%202024-02-27%20at%2014.50.55.png)

对于ALU，不仅可以执行算术逻辑指令，还要涉及内存地址的计算以及栈指针的增加或减少的操作。

## Memory Stage

访存阶段的任务就是从内存中读数据或者将数据写入内存中。

![](storage%20bag/Screenshot%202024-02-27%20at%2014.52.42.png)

访存阶段的最后操作，会根据图中的信号来计算状态码Stat。

## Write back Stage

写回阶段是将数据写入到寄存器文件，两个写端口分别为M和E，对应的地址输入为dstE和dstM。

![|425](storage%20bag/Screenshot%202024-02-27%20at%2014.55.26.png)

这里需要注意的是，当执行条件传送指令(cmov)时，写入操作还要根据执行阶段计算出的cnd信号，当不满足条件时，可以将目的寄存器设置为0xF来禁止写入寄存器文件。

## PC Update Stage

PC的值可能有三种情况：

1. 当前执行的是函数调用指令`call`，那么新的PC就等于call指令的常数字段；
2. 如果当前正在执行的指令时函数返回指令`ret`，指令ret在访存阶段会从内存(栈)中读出返回地址，这个返回地址就是新的PC值；
3. 当前执行的是跳转指令`jxx`，当cnd信号=1时，也就是满足跳转条件时，此时新的PC=跳转指令的常数字段。当不满足跳转条件时，跳转指令和其他指令一样，新的PC=当前PC+当前指令长度

这种顺序结构存在一个问题，那就是指令的执行速度太慢了，时钟必须非常慢，这样才能让所有操作在一个时钟周期内完成。因此引入了**流水线**来获得更好的性能。

