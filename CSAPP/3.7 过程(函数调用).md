## 3.7 过程（函数调用）

在大型软件的构建过程中，需要对复杂功能进行切分。而 *procedures*（过程）提供了一种封装代码的方式，它可以隐藏某个行为的具体实现，同时提供清晰简洁的接口定义。

举例：`Function` in C, `Method` in Java

### 栈帧 (Stack Frame)

当函数执行所需要的存储空间超出寄存器能够存放的大小时，就会借助栈上的存储空间 ，我们把这部分存储空间称为函数的栈帧。 ^88fc3c

![[storage bag/Screenshot 2023-11-25 at 16.42.59.png]]
> 这里返回地址的压栈操作是由函数调用指令`call`来执行的，而非`push`

![[storage bag/Screenshot 2023-11-25 at 16.48.50.png]]
> `call`不仅要将函数multstore的第一条指令地址写入到程序指令寄存器rip中，以此实现函数调用，同时还要将返回地址压入栈中。

 函数执行完毕后，指令`ret`从栈中将返回地址弹出到%rip中，函数返回，继续执行main函数的剩余内容。

### 参数传递

如果一个函数的参数数量大于6，那超出的部分就需要通过栈来传递(见[3.2 寄存器与数据传送指令](3.2%20寄存器与数据传送指令.md#^1e2683)，只有6个参数寄存器)

有两点需要注意：
1. 通过栈来传递参数时，所有数据的大小都是向8的倍数对齐：

![[storage bag/Screenshot 2023-11-25 at 16.57.42.png]]

2. 使用寄存器进行参数传递时，寄存器的时候时有特殊顺序规定的，此外，寄存器名字的使用取决于传递参数的大小。

![[storage bag/Screenshot 2023-11-25 at 17.03.03.png]]
注意这个例子中，传递的参数需要8个字节对齐，而局部变量是不需要对齐的。

在程序执行的过程中，寄存器是被所有函数共享的一种资源，为了避免寄存器使用过程中出现数据覆盖的问题，处理器规定了所有函数调用都必须遵守的寄存器的使用惯例，对于16个通用寄存器，除了寄存器rsp之外， 其它15个寄存器分别被定义为调用者保存和被调用者保存：
![[storage bag/Screenshot 2023-11-25 at 17.06.10.png]]
> 勘误：被调用者：rbx, rbp, 12-15，图中写反了

看一个递归调用的例子：
![[storage bag/Screenshot 2023-11-25 at 17.18.36.png]]
> 可以看到，每次函数调用都它私有的状态信息，栈分配与释放的规则与函数调用返回的顺序也是匹配的。

N非常大的时候，就不建议使用递归调用了，原因是本节最后会提到的 *Stack Overflow*（栈溢出）。
