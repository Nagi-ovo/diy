之前的章节中，我们了解了栈的相关知识。栈帧中会保存程序执行所需要的重要信息。如返回地址、保存的寄存器的值等。
[见3.7](3.7%20过程(函数调用).md#^88fc3c)

在C语言中，对数组的引用不会进行任何的边界检查。如果对越界的数组进行写操作，就会破坏存储在栈中的状态信息，当程序使用了被修改的返回地址时，就会导致严重的错误。

## 缓冲区溢出

### 栈随机化
*Stack Randomization*

在过去，程序的栈地址非常容易预测。栈随机化的思想是，栈的位置在每次程序运行时都有变化。
因此即使多台机器运行相同的代码，它们的栈地址也是不同的。

在Linux系统中，栈随机化已经成为标准行为，属于地址空间布局随机化的一种(*Address-Space Layout Randomization, ASLR*)。采用ASLR，每次运行时程序的不同部分都会被加载到内存的不同区域，增加了系统安全性，降低了病毒的传播速度。

### 栈破坏检测
*Stack Corruption Detection*

编译器会在产生的汇编代码中，加入一种栈保护者的机制来检测缓冲区越界，就是在缓冲区与栈保存的状态值之间存储一个特殊值 *Canary* 金丝雀。

![[storage bag/Screenshot 2023-11-25 at 20.55.50.png]]
> 金丝雀值时每次程序运行时随机产生的，不易知道其具体值。在函数返回之前，通过检测金丝雀值是否被修改来判断是否遭受攻击，

![[storage bag/Screenshot 2023-11-25 at 20.58.23.png]]
> 源操作数`fs:40`可以简单理解为一个内存地址，属于特殊的段，被操作系统标记为 **“只读”**，因此攻击者无法修改金丝雀值。

函数返回之前，通过`xor`来检查值是否被修改，如果发生修改则调用一个错误处理例程(*Routine*)。

### 限制可执行代码区域
*Limiting Executable Code Regions*

最后一种机制是消除攻击者向系统中插入可执行代码的能力，其中一种方法是限制哪些内存区域能够存放可执行代码。

在早期的 x86 架构中，处理器的内存访问控制较为简单。访问权限通常由几个标志位控制，这些标志位定义了内存区域是否可读、可写或可执行。在这些早期系统中，"可读"和"可执行"权限通常是合并在一起的，这意味着如果一个内存区域可读，它通常也是可执行的。这种设计简化了内存保护的逻辑，但它也意味着操作系统只有有限的能力来防止执行非法或恶意的代码，特别是缓冲区溢出攻击，这种攻击通过覆盖内存中的数据来注入并执行恶意代码。

#### NX位

为了提高安全性，后来的 x86 处理器引入了更细粒度的内存访问控制，包括一个名为 `"不可执行"（No Execute）位`的功能。这个 `NX位`允许操作系统指定哪些内存区域是不可执行的，与是否可读写无关。这样，操作系统就可以设置堆栈和其他敏感区域为不可执行，防止恶意软件在这些区域执行代码。

使用 NX 位后，当程序尝试执行标记为不可执行的内存区域中的代码时，处理器会拒绝执行并生成一个异常。这一机制成为数据执行防止（DEP）的基础，并被广泛用于现代操作系统中，如 Windows 的 *Data Execution Prevention* 特性和 Linux 的 *Exec Shield*。

NX 位的引入显著提高了系统的安全性，因为它允许操作系统创建一个更加安全的执行环境，使得攻击者难以通过常见的内存攻击手段（如缓冲区溢出）来执行恶意代码。而且，由于这一检查是由硬件直接支持的，它几乎不会对系统性能造成影响，这是一个重大的安全和性能的平衡设计。

上面的三种机制，都不需要程序员做任何额外的工作，都是通过编译器和操作系统来实现的，单独每一种机制都能降低漏洞的等级，组合使用更加有效。 但不幸的是，仍然有方法能够对计算机进行攻击。





