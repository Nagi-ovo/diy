![](storage%20bag/Screenshot%202024-02-27%20at%2013.45.13.png)

但并不是所有指令执行都需要经历这6个阶段，以减法运算为例：

![](storage%20bag/Screenshot%202024-02-27%20at%2014.06.33.png)
> 执行阶段负责执行具体的运算，除了输出运算结果，还会根据结果设置条件码寄存器(*Condition Code, CC*)由于减法指令不需要读写内存，因此访存阶段不需要任何操作。

## 取指阶段

这个阶段对于所有指令都是需要的，在Y86-64架构中，指令的长度并不固定。

1. **计算指令地址**：使用程序计数器（PC）当前的值作为地址来从内存中取指令。PC中存储的是当前指令的地址。
    
2. **从内存读取指令**：根据计算出的地址，从内存中读取指令。指令的长度可能不同，取决于指令本身的类型。
    
3. **更新程序计数器（PC）**：根据取出的指令长度，更新PC的值，使其指向下一条指令的地址。这通常意味着将PC的值增加取出指令的字节数。

取指阶段的正确执行对于整个指令流水线的顺畅运行至关重要。如果取指阶段出现错误（如因分支预测失败而取错指令），则可能需要清空流水线并从正确的地址重新开始取指，这会对执行效率产生负面影响。

## 译码阶段

^a758de

就是从寄存器文件中读取数据： ^e4038a

![|300](storage%20bag/Screenshot%202024-02-27%20at%2013.54.51.png)

寄存器文件有两个读端口，可以支持同时进行两个读操作。

## 执行阶段

ALU主要执行三类操作：

AL运算

计算内存引用有效地址

针对push和pop指令

## 访存阶段

主要针对内存的读写操作，既可以从内存读出数据，也可以将数据写入内存。

## 写回阶段

与译码阶段类似，都是针对寄存器文件的操作，不同的是写回阶段不是读寄存器文件，而是写寄存器文件。

## 更新PC

将PC设置成下一条指令的地址

再以跳转指令为例：

![](storage%20bag/Screenshot%202024-02-27%20at%2014.12.52.png)

通过这个统一的框架，能够处理不同类型的Y86-64指令。
