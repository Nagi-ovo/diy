通常情况下，程序将内存视为一个非常大的数组，数组的元素是由一个个字节组成，每个字节都有对应的地址*address*。所有这些地址的集合就称为**虚拟地址空间**(*virtual address space*)  

## 位模式
![[storage bag/Screenshot 2023-11-07 at 16.28.54.png]]
> 位模式

为了避免冗长和转换麻烦，我们引入了*十六进制* 来表示位模式。

![](storage%20bag/Screenshot%202023-11-07%20at%2016.35.23.png)

## 字长

![](storage%20bag/Screenshot%202023-11-07%20at%2016.38.41.png)

向后兼容：23位机器编译的程序也可以运行在64位机器上，
```shell
linux> gcc -m32 -o hello32 hello.c 

linux> gcc -m64 -o hello64 hello.c 
```
> 两个文件的主要区别还是在于程序是如何编译的，而不是运行机器的类型

![[storage bag/Screenshot 2023-11-07 at 16.45.33.png]]
> 大多数Intel兼容机采用小端模式，IBM和Sun公司则多采用大端法。很多新处理器支持双端法，哪种方式都可以配制，例如：基于ARM架构的处理器。但是Android系统和IOS系统只能运行在小端模式。

![[storage bag/Screenshot 2023-11-08 at 10.58.10.png]]
> \\0

## 位运算 Bit-Level Operations

位运算的一个常见用法就是实现**掩码运算** *Masking Operations*

如对一个数进行 `& 0x1` ，可以得到最低位
## 逻辑运算 Logical Operations

只有`0`表示`false`

## 移位运算 Shift Operations

![](storage%20bag/Screenshot%202023-11-08%20at%2011.08.10.png)

![](storage%20bag/Screenshot%202023-11-08%20at%2011.09.11.png)

![[storage bag/Screenshot 2023-11-08 at 11.12.15.png]]
> 几乎所有的编译器以及机器的组合都是对有符号数使用算数右移。
> 对于无符号数，右移一定是逻辑右移

^b67af0
