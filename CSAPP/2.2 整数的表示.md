## 2. 整数表示

## 无符号数 Unsigned Encoding
![[storage bag/Screenshot 2023-11-08 at 11.20.16.png]]

## 有符号数

使用**补码**的方式 *Two's Complement Encoding*

这里的一个重点是，对于**符号位**，不能简单把它理解为一个负号，需要理解**负权重**的概念。

![](storage%20bag/Screenshot%202023-11-08%20at%2011.25.57.png)

![](storage%20bag/Screenshot%202023-11-08%20at%2012.13.03.png)
> 这就是为什么对于有符号数来说，最小值的表示都是符号位位1，其它位为0

![[storage bag/Screenshot 2023-11-08 at 12.16.33.png]]
> `-1`的补码表示与无符号数的最大值表示一样，需要区分

```C
short int a = -12345;
unsigned short b = (unsigned short)a;
printf("a = %d, b = %u", a, b);
```
```markdown
运行上述C代码的输出会是：
a = -12345, b = 53191
```
![](storage%20bag/Screenshot%202023-11-08%20at%2012.19.45.png)
> 无符号数中与其位模式相同的值，与它之间差了两个最高项权重

对于大多数C语言的实现，有符号数和无符号数之间的转换规则是：
maintain the bit pattern, but reinterpret

The **Binary to Unsigned** conversion is given by:$$ B2U_w(\vec{x}) = x_{w-1} \cdot 2^{w-1} + x_{w-2} \cdot 2^{w-2} + \dots + x_{0} \cdot 2^{0} $$ The **Binary to Two's Complement** conversion is given by: $$ B2T_w(\vec{x}) = -x_{w-1} \cdot 2^{w-1} + x_{w-2} \cdot 2^{w-2} + \dots + x_{0} \cdot 2^{0} $$ The difference between B2U and B2T is thus: $$ B2U_w - B2T_w = x_{w-1} \cdot 2^{w-1} - (-x_{w-1} \cdot 2^{w-1}) = x_{w-1} \cdot 2^{w} $$$$ B2U_w = B2T_w + x_{w-1} \cdot 2^w ，B2T_w = B2U_w - x_{w-1} \cdot 2^w $$
有符号数到无符号数的函数映射$T2U$为：
$$ T2U_w(x) = \begin{cases} x + 2^w, & x < 0 \\ x, & x \geq 0 \end{cases} $$ 无符号数到有符号数的函数映射$U2T$为：
$$ U2T_w(u) = \begin{cases} u, & u \leq TMax_w \\ u - 2^w, & u > TMax_w \end{cases} $$

要弄明白转化规则是因为一些现实中会遇到的情况，如：
某些情况下，C语言会隐式地将有符号数强制转化为无符号数来执行运算
```c
int a = -1;
unsigned int b = 0;
if (a < b)
    printf("-1 < 0")
else
    printf("-1 > 0")
```
> 这里会得到`-1 > 0`的结果，原因是`-1`被转化为无符号数，也就是`0xFFFFFFFF`，显然$2^{32}-1\textgreater0$

此外，较小数据类型到较大数据类型的转换是可行的，反过来则不可以。

对于无符号数，使用逻辑右移即可；有符号数需要使用算数右移。
见[[2.1 信息的存储#^b67af0]]]

![[storage bag/Screenshot 2023-11-08 at 14.23.52.png]]