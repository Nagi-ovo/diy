## 3.1 程序的机器级表示
![[storage bag/Screenshot 2023-11-16 at 18.13.16.png]]
> Intel 发展历史

```bash
linux>gcc -Og -o prog main.c mstore.c
```
`gcc`，linux系统上默认的编译器；
`-Og`，编译选项，让编译器生成复合原始C代码整体结构的机器代码。实际项目中，为更高的性能会使用`-O1`、`-O2`等。
`-o`后面的参数`prog`表示生成可执行文件的文件名。

![[storage bag/Screenshot 2023-11-16 at 18.17.59.png]]
> `-S`这个编译选项就是告诉编译器GCC产生的文件类型为汇编文件。

![[storage bag/Screenshot 2023-11-16 at 18.19.16.png]]
汇编代码文件中，以`.`开头的行都是指导汇编器和链接器工作的伪指令，完全可以忽略。
```Assembly
pushq %rbx
```
这条指令的意思是将**寄存器rbx**的值压入程序栈进行保存。

### 寄存器
![[storage bag/Screenshot 2023-11-16 at 18.23.46.png]]
Intel x86-64的处理器中包含了**16**个通用目的的寄存器，用来存放**整数数据**和**指针**，图中所示的这16个寄存器名字都是以 *%r* 开头的。

#### 两个重要概念
![[storage bag/Screenshot 2023-11-16 at 18.26.14.png]]
> 这个例子中，函数A中调用了函数B，因此函数A称为调用者*Caller*，函数B被称为被调用者*Callee*。

由于调用了函数B，寄存器rbx在函数B中被修改了，逻辑上寄存器rbx的内容在调用函数B的前后应该保持一致。有两个策略可以解决问题。
##### 调用者保存寄存器
一个是函数A在调用函数B之前，提前保存寄存器rbx的内容，执行完函数B之后，再恢复寄存器rbx原来存储的内容。如上图的左半部分所示。
##### 被调用者保存寄存器
另一个策略是在函数B使用寄存器rbx之前，先保存寄存器rbx的值，在函数B返回之前，先恢复寄存器rbx原来存储的内容。如上图的右半部分所示。

对于使用哪种策略，不同的寄存器被定义成不同策略：
![[storage bag/Screenshot 2023-11-16 at 18.31.32.png]]
> 寄存器rbx被定义为 被调用者保护寄存器 *callee-saved register*

因此，`pushq %rbx`就是用来保存寄存器rbx的内容（压入栈）。在函数返回之前，使用了`pop`指令，恢复寄存器rbx的内容。
![[storage bag/Screenshot 2023-11-16 at 18.33.25.png]]

第二行汇编代码的含义是将寄存器`rbx`的内容复制到寄存器`rdx`。(AT&T语法)

### mov指令
`mov`指令的后缀`q`表示数据大小：
![[storage bag/Screenshot 2023-11-16 at 18.36.52.png]]

### call指令
对应C代码中的**函数调用**。示例中的函数返回值会保存到寄存器rax中，因此寄存器rax中保存了$x*y$ 的乘积结果。
### ret指令
函数返回。

`movq %rax, (%rbx)`将寄存器rax的值送到内存中，内存的地址就存放在寄存器rbx中。对应C代码中的 dest 赋值。

 ### C代码如何翻译成机器代码
只需要将编译选项`-S`替换为`-c`，执行这条命令即可产生`mstore.c`所对应的机器代码文件`mstore.o`。可以借助反汇编工具，如 **objdump** 来查看该二进制格式文件。

汇编器将汇编代码翻译成二进制的机器代码，那么反汇编器就是机器代码翻译成汇编代码。

![[storage bag/Screenshot 2023-11-16 at 18.53.42.png]]
> 可以发现反汇编的结果中省略了大部分`q`后缀，而在`call`和`ret`指令后保留了后缀。