![](storage%20bag/Screenshot%202024-02-27%20at%2018.49.55.png)

前面提到过[数据依赖](4.5%20流水线的通用原理.md#^279f15)，图示的指令irmovq和addq之间存在数据相关，导致了流水线产生了错误的计算结果：
![](storage%20bag/Screenshot%202024-02-27%20at%2018.54.23.png)
> 指令1还在访存阶段，立即数10还没有写回到寄存器rdx。同样，指令2处于执行阶段，立即数3也没有写回到寄存器rax中。所以在第四个时钟周期时，寄存器rdx和rax的值还都是默认值0。

我们将这种情况称为**冒险**(*Hazard*)。
和相关一样，冒险也分为两类，一类是数据冒险，一类是控制冒险。

为了避免数据冒险，我们首先想的是让指令addq暂停一下，等到指令1和指令系2完成写回操作时，再继续addq的执行。看似简单，但需要判断何时执行暂停操作，如何实现暂停操作以及暂停多久。

判断暂停的方法是指令在译码阶段读取寄存器时，通过将读取寄存器的ID值分别与执行阶段、访存阶段以及写回阶段所执行的目的寄存器进行比较，如果存在寄存器ID相等的情况，就说明指令之间存在数据相关，那么该指令就要在译码阶段等待： ^ec594c

![](storage%20bag/Screenshot%202024-02-27%20at%2019.04.25.png)

对于流水线的执行阶段，原本是要正常的执行指令，暂停之后，通过插入*bubble*来代替暂停的指令，气泡不会改变寄存器、内存、条件码以及程序状态。

虽然使用暂停可以解决数据冒险，但是基于这种机制的流水线性能并不高，这是因为程序中数据相关的情况非常的多，频繁暂停指令的执行会严重降低流水线的吞吐量。  

![](storage%20bag/Screenshot%202024-02-27%20at%2019.29.23.png)
> 先前分析过irmovq的执行细节，该指令在访存阶段没有执行任何操作

那有没有可能直接把结果传给addq，这样指令addq就不用通过暂停来等待数据写回了。

具体的实现方法可以添加一条信号线，将指令irmovq经过ALU的执行结果直接传送到指令addq的译码阶段，这种实现技术被称为**数据转发**，也称“旁路”。这使得流水线可以不用暂停就能处理大多数据冒险。 ^07ebe0

但是，还有一种类型的数据冒险不能单纯地使用转发来解决。

![](storage%20bag/Screenshot%202024-02-27%20at%2020.12.12.png)

这种情况中，指令mrmovq指令需要从内存中读取数据，由于读内存的操作发生在流水线的后期，即使采用转发逻辑也无法将值送回到过去的时间。为了解决这一类数据冒险，需要将暂停和转发结合使用。

![](storage%20bag/Screenshot%202024-02-27%20at%2020.14.00.png)

指令addq在译码阶段暂停一个周期，等到指令mrmovq访存结束后，使用旁路路径将访存结果转发到译码阶段，指令addq继续执行。

 以上就是通过流水线硬件设计来解决指令间的数据相关问题，保证指令正确执行的前提下，还能使得流水线保持较高的吞吐量。

  
