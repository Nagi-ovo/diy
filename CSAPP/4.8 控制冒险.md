首先来了解一下控制冒险(*control hazard*)出现的原因。

在流水线的设计中，我们期望每个时钟周期都能完成一条指令的执行。想要达到这个目的，流水线在每一个时钟周期都要取到一条指令，因此每次取指操作后，必须马上确定下一条指令的地址。

大部分情况是没有问题的，但当取出的指令是返回指令`ret`时，下一条指令的地址需要从栈中读出，因此必须等到访存操作结束之后才能确定下一条指令的地址。这种情况下，流水线需要进行特殊处理来避免控制冒险。

![](storage%20bag/Screenshot%202024-02-27%20at%2020.37.11.png)

还有一种情况，是取到的指令是分支条件指令时，流水线无法立即判断是否要进行跳转操作，需要先经过执行阶段才能确定是否跳转，流水线也需要进行特殊处理来避免控制冒险。

![](storage%20bag/Screenshot%202024-02-27%20at%2020.39.19.png)
> 这两种情况中，由于无法根据当前指令立刻确定下一条指令的地址，从而引发控制冒险。

![](storage%20bag/Screenshot%202024-02-27%20at%2020.46.02.png)
> 这里的ret引发的控制冒险，可以通过暂停处理新指令的方式来避免。

对于另一种情况，我们可以假定一个策略，预设分支的结果总是跳转或总是不跳转，这种猜测分支结果的方法被称为**分支预测**，分支预测的准确性对程序的性能影响很大，这是因为当出现预测错误后，需要采取相应的方法来处理。

当前假设遇到分支指令时，总是选择执行跳转：
![](storage%20bag/Screenshot%202024-02-27%20at%2022.31.25.png)
> jne到执行阶段发现不应该执行跳转，我们的预测发生了错误，此时这两条不应该出现在流水线中的指令还没有进入执行阶段。分别在执行阶段和译码阶段插入气泡，即可剔除了这两条预测错误的指令。

这样没有引发程序的错误，但是浪费两个时钟周期的浪费。

当流水线正常执行时，暂停信号和气泡信号都设置为0；当遇到时钟上升沿时，寄存器会加载它的输入来作为新的输出；当需要暂停流水线时，需要将暂停信号设为1，寄存器就算遇到上升沿也还保持以前的状态。

![](storage%20bag/Screenshot%202024-02-27%20at%2022.37.19.png)
> 这样就能实现指令阻塞在流水线的某个阶段中。

![](storage%20bag/Screenshot%202024-02-27%20at%2022.40.06.png)

往流水线中插入气泡时，可以将气泡信号设为1，此时寄存器的状态会设置成某个固定的复位配置。这个复位配置等效于指令nop的状态(不执行任何操作，只是占用一个时钟周期)