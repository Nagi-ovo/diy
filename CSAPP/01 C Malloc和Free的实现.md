# 一、预备知识

- malloc

	在堆上分配内存
 
- 箭头操作符

	```c
	// ptr指向一个类
	ptr->foo = (*ptr).foo // 这里只是表明这样相当于省去了指针解引用的表达，并非代码实现！
	```

- sbrk(size)

    sbrk()是Unix系统中的一个系统调用，用于增加或减少程序数据段大小，是早期malloc在C/C++中的底层实现核心。

![[storage bag/Pasted image 20230925145457.png|300]]

> 可执行和可链接格式（Executable and Linkable Format, 简称 ELF），通常包含程序的执行代码，即实际的机器代码指令。 出于安全考虑，`.text`段通常是只读的。

除去前提条件，malloc函数签名为
```c
void *malloc(size_t size);
```
它接受输入字节数，并返回指向该大小内存块的指针。

可以采用多种方式来实现这个功能。这里将任意选择使用`sbrk`。操作系统为进程保留堆栈和堆空间，而sbrk允许我们操作堆。sbrk(0)返回指向当前*堆顶部*的指针。sbrk(foo)将堆大小增加foo并返回先前堆顶部的指针。

- 进程间通信（IPC）

进程间通信（Inter-Process Communication, IPC）是**使**多个进程能够相互传递数据和信号的机制。在许多操作系统中，提供了多种IPC机制。可以主要分为两大类：

1. **共享内存 (Shared Memory)**：这种方法中，两个或更多的进程共享一个内存区域，通常是为了传递数据。由于它们都可以访问同一块内存，因此一个进程中的变动可以被其他进程看到。这是一种非常快速的通信方式，但需要注意同步和并发问题，以确保数据的一致性和完整性。

2. **消息传递 (Message Passing)**：在这种方法中，进程之间传递消息来通信。这些消息可以是数据、命令或其他信息。消息可以通过多种方式进行传递，例如使用管道、套接字、消息队列等。消息传递的优点是它自然地提供了一种同步机制，并且更易于理解和管理。但与共享内存相比，消息传递可能会更慢，因为它涉及数据的复制。

Message Passing的IPC上下文中，内核（kernel）起到中介的作用，帮助进程之间传递消息。

- 单链表


| Address  | Meta-data (Value) | Size |
|----------|-------------------|------|
| 0x1000   | data1             | 8B   |
|----------|-------------------|------|
| 0x1008   | data2             | 8B   |
|----------|-------------------|------|
| 0x1010   | data3             | 8B   |
|----------|-------------------|------|
| 0x1018   | data4             | 8B   |

# 二、代码实现

```c
// 自定义的malloc函数实现（非线程安全）
void *malloc(size_t size) {
    // 调用sbrk(0)来获取当前程序断点的地址。
    // 这个地址是下一个可用的内存地址，但并未真正增加任何内存空间。
    void *p = sbrk(0);

    // 调用sbrk(size)来请求额外的size字节的内存。
    // 如果成功，程序断点将会增加size字节，并返回新的程序断点地址。
    void *request = sbrk(size);

    // 检查sbrk函数调用是否失败。
    // 当sbrk失败时，它会返回(void*)-1。
    if (request == (void*) -1) {
        return NULL; // sbrk调用失败，返回NULL。
    } else {
        // 此断言确保前后两次sbrk调用的返回值相同，表明没有其他线程在此期间调用sbrk。
        // 这是一个简单的检查，确保操作不是线程安全的。
        assert(p == request); 
        return p; // 返回新分配的内存块的开始地址。
    }
}
```

当程序请求malloc分配空间时，malloc会调用sbrk增加堆大小，并返回指向新区域开头的指针。这里缺少一个技术细节，即malloc(0)应该返回NULL或另一个可以传递给free而不会造成混乱的指针，但基本上是有效的。

但说到free，它是如何工作的呢？free的原型是

`void free(void *ptr);`

当将之前从malloc返回的指针传递给free时，它应该释放空间。但是对于我们通过malloc分配的某个东西的指针来说，我们不知道与其关联的块大小。我们在哪里存储它？如果我们有一个可用的malloc函数，我们可以分配一些空间并将其存储在那里，但如果每次调用malloc都需要调用malloc来保留空间，则会遇到麻烦。

解决这个问题常见方法是，在返回指针下方保存关于内存区域*元信息*（meta-information） 的一些数据。假设堆顶当前位于0x1000，并且我们要求0x400字节。当前版本中使用了 malloc 从 sbrk 请求了 0x400 字节，并返回了 0x1000 指针。
如果相反地保存大约 16 字节以存储有关块(block) 的信息, 我们就需要从 sbrk 请求 410 字节，并返回 0x1010 指针，这样我们就可以将大小为 16 字节的元信息块隐藏起来，不让调用 malloc 的代码看到。

这样我们就能释放一个块了，但是接下来呢？从操作系统获得的堆区域必须是连续的，所以我们不能将中间的内存块返回给操作系统。即使我们愿意复制新释放区域上方的所有内容以填充空洞，以便在末尾返回空间，也无法通知所有指向堆的指针需要进行调整。

相反地, 我们可以标记该块已被释放而不将其返回给操作系统, 这样未来对malloc函数的调用可以重复使用该块。但要做到这一点, 我们需要能够访问每个块(block) 的元信息(meta information) 。有很多可能解决方法。出于简单起见, 我们将任意选择使用单链表。

因此, 对于每个内存块(block), 我们希望拥有类似以下结构：
